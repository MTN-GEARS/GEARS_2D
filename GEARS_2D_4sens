import numpy as np
import math
import matplotlib.pyplot as plt

def sens_loc_corner(min_loc,max_loc,num_sens_corner):

    if num_sens_corner == 1:
        sensor_locxc[0]=min_loc
        sensor_locyc[0]=min_loc
    if num_sens_corner == 2:
        sensor_locxc[0]=min_loc
        sensor_locyc[0]=min_loc
        sensor_locxc[1]=max_loc
        sensor_locyc[1]=max_loc
    if num_sens_corner == 3:
        sensor_locxc[0]=min_loc
        sensor_locyc[0]=min_loc
        sensor_locxc[1]=max_loc
        sensor_locyc[1]=max_loc
        sensor_locxc[2]=min_loc
        sensor_locyc[2]=max_loc
    if num_sens_corner == 4:
        sensor_locxc[0]=min_loc
        sensor_locyc[0]=min_loc
        sensor_locxc[1]=max_loc
        sensor_locyc[1]=max_loc
        sensor_locxc[2]=min_loc
        sensor_locyc[2]=max_loc
        sensor_locx[3]=max_loc*0.99
        sensor_locy[3]=min_loc*0.99

    return sensor_locxc,sensor_locyc
    
def sens_loc_bus(min_loc,max_loc,num_sens_bus):   
    
    for it in range(0,num_sens_bus):
        while (sensor_locxb[it] < 3) or (sensor_locxb[it] > 4):
            sensor_locxb[it] = np.random.uniform(min_loc,max_loc)
        while (sensor_locyb[it] < 3) or (sensor_locyb[it] > 4):
            sensor_locyb[it] = np.random.uniform(min_loc,max_loc)
    
    return sensor_locxb,sensor_locyb
    
def sens_loc_drones(min_loc,max_loc,num_sens_drones):   
    
    for it in range(0,num_sens_drones):
        sensor_locxd[it] = np.random.uniform(min_loc,max_loc)
        sensor_locyd[it] = np.random.uniform(min_loc,max_loc)
    
    return sensor_locxd,sensor_locyd
    
def defconc(minconc,maxconc,minloc,maxloc,sensor_locx,sensor_locy,per_error):
    source_locx=np.float64(0.0)
    source_locy=np.float64(0.0)
    source_conc = np.float64(100.0) #np.random.uniform(minconc,maxconc)
    while ((source_locx <= 3.0) or (source_locx >= 4.0)) and ((source_locy <= 3.0) or (source_locy >= 4.0)):
      source_locx=np.float64(np.random.uniform(minloc,maxloc))
      source_locy=np.float64(np.random.uniform(minloc,maxloc))
  
    sensor_conc = source_conc/((source_locx-sensor_locx)**2+(source_locy-sensor_locy)**2)
    
    error = ((np.random.normal(0,1,sens_locx.shape))*2-1)*per_error*sensor_conc
    sensor_conc = sensor_conc+error
    
    return source_conc,source_locx, source_locy, sensor_conc
    
def find_conc(xop,yop,xvar,yvar,cvar):
  co = cvar*((xop-xvar)**2+(yop-yvar)**2)
  return co
  
def montypython (A,B,C):
    x01=(-B+math.sqrt(B**2-4*A*C))/(2*A)
    x02=(-B-math.sqrt(B**2-4*A*C))/(2*A)
    return x01,x02
 

def findx0(A,B,C,D,E,F):
    x0c=(-D*C+A*F)/(D*B-A*E)
    
    return x0c

def find_solution(sens_conc,sens_locx,sens_locy):
    A= sens_conc[0]-sens_conc[1]
    B= -2*sens_locx[0]*sens_conc[0]+2*sens_locx[1]*sens_conc[1]
    C= -2*sens_locy[0]*sens_conc[0]+2*sens_locy[1]*sens_conc[1]
    D= sens_conc[0]*(sens_locx[0]**2+sens_locy[0]**2)-sens_conc[1]*(sens_locx[1]**2+sens_locy[1]**2)

    E= sens_conc[2]-sens_conc[3]
    F= -2*sens_locx[2]*sens_conc[2]+2*sens_locx[3]*sens_conc[3]
    G= -2*sens_locy[2]*sens_conc[2]+2*sens_locy[3]*sens_conc[3]
    H= sens_conc[2]*(sens_locx[2]**2+sens_locy[2]**2)-sens_conc[3]*(sens_locx[3]**2+sens_locy[3]**2)

    I= sens_conc[1]-sens_conc[3]
    J= -2*sens_locx[1]*sens_conc[1]+2*sens_locx[3]*sens_conc[3]
    K= -2*sens_locy[1]*sens_conc[1]+2*sens_locy[3]*sens_conc[3]
    L= sens_conc[1]*(sens_locx[1]**2+sens_locy[1]**2)-sens_conc[3]*(sens_locx[3]**2+sens_locy[3]**2)

    M = B*I-A*J
    N = B*E-A*F

    num = N*A*L-N*I*D-M*A*H+M*D*E
    den = -C*E*M+A*G*M+N*I*C-N*A*K

    if (den != 0):
        y0c = (num)/(den)
        x0c = (A*H-D*E-(C*E-A*G)*y0c)/(B*E-A*F)
        c0c = find_conc(x0c,y0c,sens_locx[0],sens_locy[0],sens_conc[0])
    else:
        print('no soln')

    return c0c,x0c,y0c
    
### main program

# close all previous plots

plt.close('all')

# Define constants

# Right now num_sens_corner+num_sens_bus+num_sens_drones must equal 4

num_sens_corner = 2 # number of sensors that are on the corners of the grid
num_sens_bus = 1    # number of sensors that are on a bus (random location on streets)
num_sens_drones=1   # number of sensors that are on a drone (random location anywhere)
num_iterations = 10 # number of iterations

min_loc = 0         # minimum integer location of grid (typically 0)
max_loc = 7         # maximum integer location of grid
per_error = 0.1     # percent error to add to concentration (i.e. 0.1 for 10% error)
debug = False       # Set to False unless you want the extra print statemetns for debugging
do_plots= False     # Set to False unless you want to create a figure for every iteration 

# Define arrays

sensor_locxc=np.zeros(num_sens_corner, dtype=np.float64)
sensor_locyc=np.zeros(num_sens_corner, dtype=np.float64)
sensor_locxb=np.zeros(num_sens_bus,dtype=np.float64)
sensor_locyb=np.zeros(num_sens_bus,dtype=np.float64)
sensor_locxd=np.zeros(num_sens_drones,dtype=np.float64)
sensor_locyd=np.zeros(num_sens_drones,dtype=np.float64)

x0c_stats=np.zeros(num_iterations)
y0c_stats=np.zeros(num_iterations)
c0c_stats=np.zeros(num_iterations)

for i in range(0,num_iterations):
    # Define sensor locations
    sens_locxc, sens_locyc = sens_loc_corner(min_loc,max_loc,num_sens_corner)
    sens_locxb, sens_locyb = sens_loc_bus(min_loc,max_loc,num_sens_bus)
    sens_locxd, sens_locyd = sens_loc_drones(min_loc,max_loc,num_sens_drones)
    
    # Create one array of all the sensor locations
    sens_locx = np.append(sens_locxc,sens_locxb)
    sens_locx = np.append(sens_locx,sens_locxd)
    sens_locy = np.append(sens_locyc,sens_locyb)
    sens_locy = np.append(sens_locy,sens_locyd)
    
    # Randomly choose source location and concentration and add error
    
    c0,x0,y0,sens_conc = defconc(1,100,min_loc,max_loc,sens_locx,sens_locy,per_error)

    if debug:
        print('******************************************')
        print('Assumed Source Location: '+str(x0)+' , '+str(y0))
        print('Assumed Source Concentration: '+str(c0))
        print('--------------------------------------------------------')

    # Find calculated source location and concentration
    
    c0c,x0c,y0c = find_solution(sens_conc,sens_locx,sens_locy)
    
    # Define statistics
    
    x0c_stats[i] = (x0c-x0)/x0*100
    y0c_stats[i] = (y0c-y0)/y0*100
    c0c_stats[i] = (c0c-c0)/c0*100
    
    if debug:
        print('******************************************')
        print('Calculated Source Location: '+str(x0c)+' , '+str(y0c))
        print('Calculated Source Concentration: '+str(c0c))
        print('Calculated Source Location Error: '+str(x0c_stats[i])+' , '+str(y0c_stats[i]))
        print('Calculated Source Concentration: '+str(c0c_stats[i]))
        print('--------------------------------------------------------') 
        
    if do_plots:    
        plt.figure()
        plt.xlim((min_loc,max_loc))
        plt.ylim((min_loc,max_loc))
    
        plt.axvspan(0, 7, color='g', alpha=0.5, lw=0)
        plt.axvspan(3, 4,color='grey', alpha=0.5, lw=0)
        plt.axhspan(3, 4,color='grey', alpha=0.5, lw=0)

        plt.scatter(x0,y0,4*c0,color='r',marker='*')

        for it in range(0,num_sens_corner):
            plt.scatter(sens_locxc[it],sens_locyc[it],s=500,color='blue')
 
        for it in range(0,num_sens_bus):
            plt.scatter(sens_locxb[it],sens_locyb[it],s=300,color='purple', marker='4')
       
        for it in range(0,num_sens_drones):
            plt.scatter(sens_locxd[it],sens_locyd[it],s=300,color='orange', marker='8')
    
        plt.scatter(x0c,y0c,c0c,color='green',marker='^')

# Print Median and Mean (average) error over all iterations

print('**************************************************')
print('Median Error in X Location '+str(np.median(x0c_stats)))
print('Median Error in Y Location '+str(np.median(y0c_stats)))
print('Median Error in Concentration '+str(np.median(c0c_stats)))
print('**************************************************') 

print('**************************************************')
print('Mean Error in X Location '+str(np.mean(x0c_stats)))
print('Mean Error in Y Location '+str(np.mean(y0c_stats)))
print('Mean Error in Concentration '+str(np.mean(c0c_stats)))
print('**************************************************') 

plt.show()
